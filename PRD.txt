# PRD: Локальный «ChatGPT Archive Explorer»

## 1. Видение и цель

**Цель продукта:**
Сделать из сырых файлов экспорта ChatGPT (`conversations.json`, `chat.html` и сопутствующих ресурсов) удобную **локальную базу знаний**:

* чаты разложены по **проектам/папкам** (в т.ч. по `gizmo_id`),
* каждая беседа доступна в **читабельном виде** (Markdown/HTML),
* есть **поиск**, фильтры, работа с **картинками/файлами**,
* всё работает **офлайн** и **ничего никуда не отправляет**.

Рабочее название: **ChatGPT Archive Explorer**.

---

## 2. Область и границы проекта

### Входит в MVP

1. Импорт **папки экспорта ChatGPT** (распакованный `.zip`).
2. Парсинг `conversations.json` и раскладка диалогов:

   * по **проектам/гизмам** (`gizmo_id`),
   * внутри проекта — по **отдельным чатам** (файлы/папки).
3. Генерация на диске **читаемых файлов чатов** (Markdown или HTML).
4. Обработка и сохранение **картинок/ресурсов**, если они есть в экспорте.
5. **Локальный интерфейс** (web/desktop) для:

   * просмотра проектов и чатов,
   * поиска по тексту,
   * фильтрации по дате, проекту, модели и т.п.
6. Перезапуск конвертации при появлении **нового экспорта** (инкрементально или с нуля — обсуждается).

### Не входит в MVP (можно на v2+)

* Редактирование контента чатов в интерфейсе (изменение текста).
* Синхронная «подтяжка» новых чатов напрямую из аккаунта (только работа с экспортами).
* Автоматическая дедупликация между несколькими экспортами.
* Совместная работа нескольких пользователей.

---

## 3. Целевой пользователь и сценарии

### Профиль пользователя

* Активный пользователь ChatGPT с большим количеством диалогов.
* Разработчик/трейдер/ресёрчер, который:

  * регулярно возвращается к старым чатам,
  * хочет иметь **офлайн-копию**,
  * хочет использовать эти данные в своём стеке (Obsidian, локальные LLM, скрипты).

### Ключевые сценарии

1. **“Хочу локальную копию всего”**

   * Пользователь скачал экспорт ChatGPT (.zip), распаковал в папку.
   * Запускает конвертер, указывает путь.
   * Получает на диске структуру из папок проектов и файлов чатов.

2. **“Найти старый ответ/код/идею”**

   * Запускает локальный UI.
   * Вбивает ключевые слова: «funding-арбитраж ETH», «PRD wallet», «bull put spread».
   * Видит список релевантных чатов с подсветкой совпадений.

3. **“Работа по проектам, как в Projects”**

   * В левой колонке — список проектов (групп по `gizmo_id`).
   * Внутри проекта — список чатов по дате.
   * Можно быстро переключаться между ними, как в ChatGPT Projects.

4. **“Интеграция с файловой системой / PKM”**

   * Пользователь знает, что каждый чат — это файл `.md`/`.html` на диске.
   * Может добавить эти папки в Obsidian, Git-репозиторий, синкнуть в Syncthing и т.п.

---

## 4. Входные данные и их особенности

### Структура стандартного экспорта ChatGPT

Ожидается папка, полученная из `.zip` экспорта ChatGPT, внутри которой минимум:

* `conversations.json` — основной источник данных:

  * массив объектов-бесед,
  * у каждой есть:

    * `title`,
    * `create_time`, `update_time`,
    * `mapping` — дерево сообщений,
    * внутри сообщений:

      * `author.role` (`user`, `assistant`, `system`, `tool` и т.д.),
      * `content` (часто `content_type: "text"`, `parts: [ ... ]`),
      * `metadata`, где могут быть:

        * `gizmo_id` (ID проекта/кастомного GPT),
        * `model_slug`,
        * `reasoning_status` и прочее.

* `chat.html` — свёрнутое HTML-представление всех чатов (на случай fallback/сверки).

Могут быть и другие файлы/папки (ресурсы, вложения), их нужно:

* либо игнорировать,
* либо аккуратно использовать, если формат очевиден.

### Важные особенности

* Структура `mapping` — **дерево**, а не простой список; надо:

  * восстановить **линейный порядок сообщений**,
  * корректно отобрать основную ветку диалога (без форков или с минимальной логикой выбора ветки).
* `gizmo_id` может:

  * быть одинаковым у многих бесед → естественная группа «проект»,
  * отсутствовать → чаты попадают в группу «Без проекта».
* Схема экспорта **может меняться** — парсер должен:

  * игнорировать неизвестные поля,
  * не падать, если каких-то полей нет.

---

## 5. Основные функциональные требования (MVP)

### 5.1. Импорт и парсинг

1. Пользователь выбирает:

   * либо путь к **распакованной папке** экспорта,
   * либо путь к `.zip`, который будет автоматически распакован во временную директорию/целевой каталог.
2. Система:

   * проверяет наличие `conversations.json`,
   * валидирует формат (минимальная проверка: JSON-массив, у элементов есть `mapping`).
3. Для каждой беседы в `conversations.json` система:

   * извлекает:

     * `title`,
     * `create_time` / `update_time`,
     * список сообщений (превращая дерево `mapping` в последовательность),
     * `gizmo_id` (если есть),
     * модель, роли, метаданные.
   * формирует внутреннюю структуру, примерно:

     * `conversation_id` (сгенерированный UUID или hash),
     * `project_id` (значение `gizmo_id` или `null`),
     * `messages: [ {role, text, timestamp, metadata}, ... ]`.

### 5.2. Структура файлов на диске

Корневой каталог архива (задаётся пользователем, напр. `D:\ChatGPT-Archive`):

```text
D:\ChatGPT-Archive\
  index.db                    # База индекса/поиска (опционально)
  meta.json                   # Общая информация об импортах
  projects\
    no_project\
      _meta.json
      2025-11-30 - Создание резервной копии\
        conversation.json
        conversation.md
    g-p-68e4ed93618c8191b83c2934270e204f\
      _meta.json              # описание «проекта»
      2025-11-30 - PRD wallet\
        conversation.json
        conversation.md
        images\
          img_001.png
          img_002.png
```

**Требования:**

* Названия папок чатов:
  `YYYY-MM-DD - <title>`
  (если `title` пустой — использовать `"Untitled"` + часть `conversation_id`).

* `conversation.json` — «сырой + нормализованный» формат:

  * ссылка на оригинальный индекс из `conversations.json` (например `source_index`),
  * список сообщений с чистым текстом.

* `conversation.md` — человеко-читаемое представление:

  ```markdown
  # Создание резервной копии
  Дата: 2025-11-30 21:45

  ---
  **User:**  
  Как создать резервную копию всех чатов ChatGpt?

  **Assistant:**  
  (ответ...)
  ```

* `images/` — локальные копии картинок, если их удаётся извлечь или скачать (при условии отдельного флага, чтобы не трогать сеть по умолчанию).

### 5.3. Группировка по проектам (`gizmo_id`)

1. Для каждой беседы определяется `project_id`:

   * если `message.metadata.gizmo_id` найден у любого сообщения — берём это значение;
   * если не найден — `project_id = "no_project"`.

2. При генерации файлов:

   * создаётся папка `projects/<project_id>/`,
   * там лежат папки отдельных бесед.

3. Для `projects/<project_id>/_meta.json`:

   ```json
   {
     "project_id": "g-p-68e4ed93618c8191b83c2934270e204f",
     "human_name": "Project g-p-68e4ed9",
     "conversation_count": 12,
     "first_message_time": 1764400000,
     "last_message_time": 1764600000
   }
   ```

   В дальнейшем пользователь может руками отредактировать `human_name` (например, назвать "Wallet design"), а UI должен подхватывать это имя.

### 5.4. Локальный UI: просмотр и навигация

MVP UI (локальный web-интерфейс, запускается командой типа `chatgpt-archive serve`):

1. **Левая колонка: Проекты**

   * список проектов:

     * «Без проекта»,
     * `Project g-p-68e4ed9` (или переименованное имя из `_meta.json`),
     * и т.д.
   * возле каждого — счётчик чатов.

2. **Средняя колонка: Список чатов**

   * отфильтрован по выбранному проекту,
   * сортировка по дате обновления (по умолчанию — новые сверху),
   * каждая строчка:

     * дата,
     * название,
     * краткий сниппет первого пользовательского сообщения.

3. **Правая часть: Просмотр чата**

   * отрисованный `conversation.md`/HTML:

     * чётко отделены `User` / `Assistant` / `System`,
     * моноширинный шрифт для кодовых блоков,
     * если есть картинки — показываются инлайном (из `images/`).
   * кнопки:

     * «Открыть файл в проводнике»,
     * «Скопировать как Markdown»,
     * «Открыть сырой JSON».

### 5.5. Поиск и фильтры (MVP)

1. **Поиск по тексту**:

   * единая строка поиска в шапке UI;
   * поиск по:

     * тексту сообщений,
     * заголовкам,
     * опционально — по `model_slug`.
   * результаты:

     * список чатов, отсортированный по релевантности,
     * подсветка совпадений в сниппете.

2. **Фильтры**:

   * по дате: интервал (от/до),
   * по роли (только в тексте пользователя / только в ответах ассистента),
   * по проекту (синхронизируется с левой колонкой),
   * по модели (список моделей, найденных в экспорте).

Реализация поиска:

* MVP-уровень — SQLite с FTS / лёгкий встроенный движок;
* главное требование: не уходить в внешние сервисы, всё локально.

---

## 6. Нефункциональные требования

1. **Полная офлайн-работа**:

   * по умолчанию приложение **не делает внешних HTTP-запросов**,
   * опция «разрешить догружать картинки по ссылкам» должна быть явной и отключена по умолчанию.

2. **Производительность**:

   * импорт и индексация:

     * ориентир: десятки тысяч сообщений / тысячи чатов должны обрабатываться за разумное время (минуты, а не часы);
   * UI:

     * список чатов до нескольких тысяч — без лагов при скролле/фильтрах.

3. **Надёжность**:

   * если какая-то беседа сломана (неполный JSON), она **логируется** и пропускается, но процесс не ломается;
   * если структура экспорта изменилась — приложение должно:

     * аккуратно ругаться и показывать пользователю «неизвестный формат»,
     * по возможности продолжать работать с тем, что понятно.

4. **Кроссплатформенность**:

   * минимум: Windows 11 (твой основной кейс),
   * желательно, чтобы можно было запустить и на Linux/macOS (хотя бы через Python-скрипт + браузер).

---

## 7. Пользовательские потоки (flows)

### 7.1. Первичный импорт

1. Пользователь скачивает экспорт ChatGPT → распаковывает `.zip` в, например, `D:\ChatGPT-export-2025-12-02`.
2. Запускает:

   ```bash
   chatgpt-archive import "D:\ChatGPT-export-2025-12-02" --output "D:\ChatGPT-Archive"
   ```

   (или через GUI «Выбрать папку экспорта» + «Выбрать целевую папку архива».)
3. Система:

   * валидирует структуру,
   * парсит `conversations.json`,
   * создаёт `projects/…`, `conversation.md`, `index.db`.
4. В конце показывает краткий отчёт:

   * `Импортировано бесед: 742`,
   * `Групп по gizmo_id: 9 (+1 no_project)`.

### 7.2. Открытие архива и поиск

1. Пользователь запускает:

   ```bash
   chatgpt-archive serve --root "D:\ChatGPT-Archive"
   ```
2. В браузере открывается UI.
3. Пользователь выбирает проект справа/слева, просматривает чаты.
4. Вбивает запрос «funding rate Lighter ETH» → получает список чатов, кликает → читает.

### 7.3. Переимпорт / обновление

1. Пользователь скачал новый экспорт (`…2025-12-20`) с более свежими чатами.
2. Запускает импорт с тем же `--output`:

   * система:

     * либо перегенерирует всё с нуля (простой вариант),
     * либо пытается выявить новые беседы и добавить их (опциональный режим `--incremental`).

---

## 8. Расширения (v2+)

Возможные направления развития:

1. **Инкрементальные обновления**:

   * отслеживание уже импортированных `conversation_id`,
   * добавление только новых чатов при следующем экспорте.

2. **Аннотации и теги**:

   * возможность помечать чаты локальными тегами (`#trading`, `#wallet`, `#idea`),
   * хранить их в локальном `meta.json`/БД, не ломая исходные файлы.

3. **Интеграция с локальными LLM**:

   * возможность задать вопрос «по всем чатам» и получить ответ от локальной модели, использующей этот архив как базу знаний.

4. **Экспорт в сторонние системы**:

   * генерация структуры, оптимизированной под Obsidian (датированные заметки с фронтматтером),
   * экспорт в Notion / Roam / Logseq (через `.md`/`.json`).

---

## 9. Открытые вопросы

1. **Формат хранения индекса:**

   * использовать ли SQLite FTS (простой и мощный),
   * или, пока объёмы умеренные, сделать in-memory индекс при старте и простой поиск?

2. **Обработка вложений и картинок:**

   * какие именно структуры в экспорте использовать для поиска картинок (нужно будет пройтись по реальным файлам),
   * делать ли опцию «скачать все remote-изображения по URL» или оставить только то, что есть в экспорте.

3. **Ветвления диалогов (branches):**

   * как обрабатывать форки веток в `mapping`:

     * брать только основную ветку (по `current_node` / по последнему `assistant`),
     * или добавлять пометки внутри `conversation.md`, что есть альтернативные ветки?

---

Если хочешь, следующий шаг — превратить это PRD в конкретный **репозиторий-скелет**:

* структура проекта,
* `config.json`,
* базовый `import.py`,
* прототип `serve.py` с простым HTML-UI,

чтобы ты мог сразу начать коммитить и допиливать под себя.
